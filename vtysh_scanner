#!/usr/bin/perl
#
# vtysh_scanner - print a network graph of routing information
# 
# Copyright (C) 2011,2014,2015,2018  Christian Garbs <mitch@cgarbs.de>
# Licensed under GNU GPL 3 or later.
# 
use strict;
use warnings;

### global configuration
my $ALLOW_SELF = 1;  # set to 0 to remove self-references, eg. in lines like AS1 AS2 AS2 AS2 AS3 skip the 'AS2 AS2' pairs

### subroutines

sub read_vtysh_paths()
# read path information from vtysh
{
    my @ret;

    my $startcol = 0;
    while (my $line = <STDIN>)
    {
	if ($line =~ /^((\*>?)\s.*) i/)
	{
	    next if length($1) < $startcol;

	    # check whether that line is active
	    my $active = $2 eq '*>';
	    
	    my $as = substr($1, $startcol);
	    # skip first element, that is always us
	    $as =~ s/^[^0-9]+//;
	    push @ret, { ACTIVE => $active, PATH => $as };
	}
	elsif ($line =~ /Path/)
	{
	    # figure out on which column the paths begin
	    $startcol = index $line, 'Path';
	}
    }
    return @ret;
}

sub show_help()
# print help text
{
    print<<"EOF";
usage:  $0 <local AS id>
        $0 [-h]--help]

$0 expects the output of `vtysh -c 'show ip bgp'` on stdin.
$0 writes a PNG file containing the graph to stdout.

examples:
   vtysh -c 'show ip bgp' | $0 65001     process data for AS 65001
   $0 -h                                 show help text
EOF
    ;
}


### parse commandline arguments

if (@ARGV != 1)
{
    show_help();
    exit 1;
}

if ($ARGV[0] eq '-h' or $ARGV[0] eq '--help' )
{
    show_help;
    exit 0;
}
my $my_as = $ARGV[0];


### read configuration

my %config;
if ( -r 'info.conf')
{
    open my $config, '<', 'info.conf' or die "can't open `info.conf': $!";
    while (my $line = <$config>)
    {
	$line =~ s/^\s+//;
	$line =~ s/\s+$//;
	next if $line eq '';
	next if $line =~ /^#/;
	my ($as, $name, $type) = split /\s+/, $line;
	$config{$as}->{NAME} = $name if defined $name;
	$config{$as}->{TYPE} = $type if defined $type;
    }
    close $config or die "can't close `info.conf': $!";
}


### collect information

my %peering;
my %as;

my %active;

foreach my $line (read_vtysh_paths())
{
    my $last_as = undef;
    foreach my $as ( $my_as, split (/ /, $line->{PATH}) )
    {
	$as{$as}++;
	
	if (defined $last_as)
	{
	    # undirected peerings are sorted to skip duplicates
	    my ($from, $to) = sort ($as, $last_as);
	    
	    # skip self-references (eg. prepended paths to downgrade a route)
	    if ($ALLOW_SELF or $from ne $to)
	    {
		$peering{"$from:$to"}++;
	    }

	    # active peerings are directed, they can exist only once
	    $active{"${last_as}:${as}"}++ if $line->{ACTIVE};
	}
	    
	$last_as = $as;
    }
}


### print graph

use GraphViz;

my $g = GraphViz->new();

foreach my $as (keys %as)
{
    $g->add_node($as);
    $g->add_node($as, label => "$as\n$config{$as}->{NAME}")  if exists $config{$as}->{NAME};
    $g->add_node($as, style => 'filled', fillcolor => 'lightgrey') if exists $config{$as}->{TYPE};
    $g->add_node($as, style => 'filled', fillcolor => 'lightblue') if $as == $my_as;
}

foreach my $peering (keys %peering)
{
    die unless $peering =~ /(.*):(.*)/;
    if (exists $active{$peering})
    {
	$g->add_edge($1 => $2);
    }
    elsif (exists $active{"$2:$1"})
    {
	$g->add_edge($2 => $1);
    }
    else
    {
	$g->add_edge($1 => $2, 'dir' => 'none', weight => 0, color => '0, 0, 0.5');
    }
}

print $g->as_png;

